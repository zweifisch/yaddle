// Generated by CoffeeScript 1.9.2
(function() {
  var ParseError, generateJSONSchema, keywords, match, matchArray, parse, parseYAML,
    slice = [].slice;

  keywords = {
    str: true,
    int: true,
    num: true
  };

  matchArray = function(input, pattern, shift) {
    var idx, j, len, p, ret;
    if (shift == null) {
      shift = 0;
    }
    ret = [];
    for (idx = j = 0, len = pattern.length; j < len; idx = ++j) {
      p = pattern[idx];
      if ("string" === typeof p && "$" === p.charAt(0)) {
        ret.push(input[idx + shift]);
      } else {
        if (p !== input[idx + shift]) {
          return;
        }
      }
    }
    return ret;
  };

  match = function() {
    var args, failed, i, input, j, ref, shift, values;
    input = arguments[0], shift = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];
    failed = args.length % 2 ? args.pop() : void 0;
    for (i = j = 0, ref = args.length / 2; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
      if (values = matchArray(input, args[i + i], shift)) {
        return args[i + i + 1].apply(args, values);
      }
    }
    if (failed) {
      return failed();
    }
  };

  ParseError = function(message, lineno, pos) {
    return message + " at " + lineno + ":" + pos;
  };

  parseYAML = function(input) {
    var buffered, cur, curlineIndent, i, indent, indenting, j, lastlineIndent, lengthOpen, lineno, pos, prev, ref, ret, skip, skipWhiteSpace, startNewline, tokens;
    ret = {};
    indenting = false;
    indent = {
      "with": "",
      count: 0
    };
    lastlineIndent = 0;
    curlineIndent = 0;
    prev = null;
    lineno = 1;
    pos = 0;
    buffered = "";
    skip = false;
    tokens = [];
    lengthOpen = false;
    skipWhiteSpace = false;
    for (i = j = 0, ref = input.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      cur = input.charAt(i);
      if (startNewline) {
        startNewline = false;
        lastlineIndent = curlineIndent;
        indenting = false;
        buffered = "";
        lineno += 1;
        pos = 1;
      } else {
        pos += 1;
      }
      switch (cur) {
        case "\n":
          startNewline = true;
          lastlineIndent = curlineIndent;
          if (buffered) {
            tokens.push(buffered);
          }
          break;
        case " ":
          if (pos === 1) {
            if (indent["with"]) {
              if (indent["with"] !== " ") {
                throw ParseError("mixed indentation", lineno, pos);
              }
            } else {
              indent["with"] = " ";
            }
            switch (prev) {
              case null:
                throw ParseError("unexpected indentation", lineno, pos);
            }
            indenting = true;
          }
          skip = !indenting && skipWhiteSpace;
          break;
        case "\t":
          if (pos === 1) {
            if (indent["with"]) {
              if (indent["with"] !== "\t") {
                throw ParseError("mixed indentation", lineno, pos);
              }
            } else {
              indent["with"] = "\t";
            }
            switch (prev) {
              case null:
                throw ParseError("unexpected indentation", lineno, pos);
            }
            indenting = true;
          }
          break;
        case ":":
          tokens.push(":indent");
          tokens.push(curlineIndent);
          tokens.push(":key");
          tokens.push(buffered);
          buffered = "";
          skip = true;
          skipWhiteSpace = true;
          break;
        case "{":
          if (!keywords[buffered]) {
            throw ParseError("unexpected type '" + buffered + "'", lineno, pos);
          }
          tokens.push(buffered);
          tokens.push("{");
          buffered = "";
          skip = true;
          lengthOpen = true;
          break;
        case "}":
          if (!lengthOpen) {
            throw ParseError("unexpected }", lineno, pos);
          }
          lengthOpen = false;
          if (buffered) {
            tokens.push(buffered);
          }
          tokens.push("}");
          buffered = "";
          skip = true;
          break;
        case ",":
          if (!lengthOpen) {
            throw ParseError("unexpected ,", lineno, pos);
          }
          if (buffered) {
            tokens.push(buffered);
          }
          tokens.push(",");
          buffered = "";
          skip = true;
          break;
        case "\r":
          skip = true;
          break;
        default:
          skipWhiteSpace = false;
          if (indenting) {
            indenting = false;
            if (indent.count) {
              if (buffered.length % indent.count) {
                throw ParseError("bad indentation", lineno, pos);
              }
            } else {
              indent.count = buffered.length;
            }
            curlineIndent = buffered.length / indent.count;
            buffered = "";
            if (curlineIndent > lastlineIndent + 1) {
              throw ParseError("over indented", lineno, pos);
            }
          }
      }
      if (skip) {
        skip = false;
      } else {
        buffered += cur;
      }
      prev = cur;
    }
    if (buffered) {
      tokens.push(buffered);
    }
    return tokens;
  };

  generateJSONSchema = function(input) {
    var base, base1, i, indent, j, k, key, level, node, objectStack, ref, ref1, ret, token;
    ret = {};
    level = -1;
    objectStack = [{}];
    for (i = j = 0, ref = input.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      token = input[i];
      switch (token) {
        case ":indent":
          indent = input[i + 1];
          key = input[i + 3];
          if (indent > level) {
            objectStack.push({});
            if ((base = objectStack[objectStack.length - 2]).properties == null) {
              base.properties = {};
            }
            if ((base1 = objectStack[objectStack.length - 2]).type == null) {
              base1.type = "object";
            }
            objectStack[objectStack.length - 2].properties[key] = objectStack[objectStack.length - 1];
            i += 4;
          } else if (indent === level) {
            objectStack[objectStack.length - 1] = {};
            objectStack[objectStack.length - 2].properties[key] = objectStack[objectStack.length - 1];
            objectStack[objectStack.length - 2].properties[key] = objectStack[objectStack.length - 1];
            i += 4;
          } else if (indent < level) {
            for (i = k = 0, ref1 = level - indent; 0 <= ref1 ? k <= ref1 : k >= ref1; i = 0 <= ref1 ? ++k : --k) {
              objectStack.pop();
            }
          }
          level = indent;
          break;
        case "str":
          node = objectStack[objectStack.length - 1];
          node.type = "string";
          if ("{" === input[i + 1]) {
            match(input, i + 1, ["{", "$min", ",", "$max", "}"], function(min, max) {
              node.minLength = min;
              node.maxLength = max;
              return i += 5;
            }, ["{", "$min", ",", "}"], function(min) {
              node.minLength = min;
              return i += 4;
            }, ["{", ",", "$max", "}"], function(max) {
              node.maxLength = max;
              return i += 4;
            }, ["{", "$max", "}"], function(max) {
              node.maxLength = max;
              return i += 3;
            }, function() {
              throw Error("incorrect str format");
            });
          }
          break;
        case "int":
          node = objectStack[objectStack.length - 1];
          node.type = "number";
          node.multipleOf = 1;
          if ("{" === input[i + 1]) {
            match(input, i + 1, ["{", "$min", ",", "$max", "}"], function(min, max) {
              node.minimum = min;
              node.maximum = max;
              return i += 5;
            }, ["{", "$min", ",", "}"], function(min) {
              node.minimum = min;
              return i += 4;
            }, ["{", ",", "$max", "}"], function(max) {
              node.maximum = max;
              return i += 4;
            }, ["{", "$max", "}"], function(max) {
              node.maximum = max;
              return i += 3;
            }, function() {
              throw Error("incorrect str format");
            });
          }
          break;
        case ":key":
          "pass";
      }
    }
    return objectStack[0].properties;
  };

  module.exports = {
    parse: parse = function(input) {
      return generateJSONSchema(parseYAML(input));
    },
    loads: function(file) {
      return new Promise(function(resolve, reject) {
        return fs.readFile(file, function(err, content) {
          if (err) {
            return reject(err);
          } else {
            return resolve(parse(content));
          }
        });
      });
    },
    ParseError: ParseError
  };

}).call(this);
